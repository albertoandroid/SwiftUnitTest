//
//  UnitTestSwiftCourseTests-UnitTestSwiftCourseMocks.generated.swift
//  UnitTestSwiftCourse
//
//  Generated by Mockingbird v0.13.0.
//  DO NOT EDIT
//

@testable import Mockingbird
@testable import UnitTestSwiftCourse
import Foundation
import Swift
import UIKit

private var genericTypesStaticMocks = Mockingbird.Synchronized<[String: Mockingbird.StaticMock]>([:])

// MARK: - Mocked Add

public final class AddMock: UnitTestSwiftCourse.Add, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.13.0", "module_name": "UnitTestSwiftCourse"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AddMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`validNumber`: UnitTestSwiftCourse.ValidNumber, __file: StaticString = #file, __line: UInt = #line) -> AddMock {
      let mock: AddMock = AddMock(validNumber: `validNumber`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public static func initialize(`validNumber`: UnitTestSwiftCourse.ValidNumber, `print`: UnitTestSwiftCourse.Print, __file: StaticString = #file, __line: UInt = #line) -> AddMock {
      let mock: AddMock = AddMock(validNumber: `validNumber`, print: `print`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked print

  override public var `print`: UnitTestSwiftCourse.Print? {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "print.get", arguments: [], returnType: Swift.ObjectIdentifier((UnitTestSwiftCourse.Print?).self))
      return mockingContext.didInvoke(invocation) { () -> UnitTestSwiftCourse.Print? in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> UnitTestSwiftCourse.Print? {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (UnitTestSwiftCourse.Print?).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "print.set", arguments: [ArgumentMatcher(newValue)], returnType: Swift.ObjectIdentifier(Void.self))
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (UnitTestSwiftCourse.Print?) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getPrint() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> UnitTestSwiftCourse.Print?, UnitTestSwiftCourse.Print?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "print.get", arguments: [], returnType: Swift.ObjectIdentifier((UnitTestSwiftCourse.Print?).self))
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> UnitTestSwiftCourse.Print?, UnitTestSwiftCourse.Print?>(mock: self, invocation: invocation)
  }

  public func setPrint(_ newValue: @escaping @autoclosure () -> UnitTestSwiftCourse.Print?) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (UnitTestSwiftCourse.Print?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "print.set", arguments: arguments, returnType: Swift.ObjectIdentifier(Void.self))
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (UnitTestSwiftCourse.Print?) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked validNumber

  override public var `validNumber`: UnitTestSwiftCourse.ValidNumber {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "validNumber.get", arguments: [], returnType: Swift.ObjectIdentifier((UnitTestSwiftCourse.ValidNumber).self))
      return mockingContext.didInvoke(invocation) { () -> UnitTestSwiftCourse.ValidNumber in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> UnitTestSwiftCourse.ValidNumber {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (UnitTestSwiftCourse.ValidNumber).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "validNumber.set", arguments: [ArgumentMatcher(newValue)], returnType: Swift.ObjectIdentifier(Void.self))
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (UnitTestSwiftCourse.ValidNumber) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getValidNumber() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> UnitTestSwiftCourse.ValidNumber, UnitTestSwiftCourse.ValidNumber> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "validNumber.get", arguments: [], returnType: Swift.ObjectIdentifier((UnitTestSwiftCourse.ValidNumber).self))
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> UnitTestSwiftCourse.ValidNumber, UnitTestSwiftCourse.ValidNumber>(mock: self, invocation: invocation)
  }

  public func setValidNumber(_ newValue: @escaping @autoclosure () -> UnitTestSwiftCourse.ValidNumber) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (UnitTestSwiftCourse.ValidNumber) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "validNumber.set", arguments: arguments, returnType: Swift.ObjectIdentifier(Void.self))
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (UnitTestSwiftCourse.ValidNumber) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `add`(`a`: Int, `b`: Int)

  public override func `add`(`a`: Int, `b`: Int) -> Int {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`add`(`a`: Int, `b`: Int) -> Int", arguments: [Mockingbird.ArgumentMatcher(`a`), Mockingbird.ArgumentMatcher(`b`)], returnType: Swift.ObjectIdentifier((Int).self))
    return mockingContext.didInvoke(invocation) { () -> Int in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Int, Int) -> Int {
        return concreteImplementation(`a`, `b`)
      } else if let concreteImplementation = implementation as? () -> Int {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Int).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `add`(`a`: @escaping @autoclosure () -> Int, `b`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int, Int) -> Int, Int> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`a`), Mockingbird.resolve(`b`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`add`(`a`: Int, `b`: Int) -> Int", arguments: arguments, returnType: Swift.ObjectIdentifier((Int).self))
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int, Int) -> Int, Int>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `addPrint`(`a`: Int, `b`: Int)

  public override func `addPrint`(`a`: Int, `b`: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addPrint`(`a`: Int, `b`: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`a`), Mockingbird.ArgumentMatcher(`b`)], returnType: Swift.ObjectIdentifier((Void).self))
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Int, Int) -> Void {
        concreteImplementation(`a`, `b`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `addPrint`(`a`: @escaping @autoclosure () -> Int, `b`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int, Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`a`), Mockingbird.resolve(`b`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addPrint`(`a`: Int, `b`: Int) -> Void", arguments: arguments, returnType: Swift.ObjectIdentifier((Void).self))
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int, Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(`validNumber`: UnitTestSwiftCourse.ValidNumber)

  public required override init(`validNumber`: UnitTestSwiftCourse.ValidNumber) {
    super.init(validNumber: `validNumber`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`validNumber`: UnitTestSwiftCourse.ValidNumber) ", arguments: [Mockingbird.ArgumentMatcher(`validNumber`)], returnType: Swift.ObjectIdentifier((Void).self))
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`validNumber`: UnitTestSwiftCourse.ValidNumber, `print`: UnitTestSwiftCourse.Print)

  public required override init(`validNumber`: UnitTestSwiftCourse.ValidNumber, `print`: UnitTestSwiftCourse.Print) {
    super.init(validNumber: `validNumber`, print: `print`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`validNumber`: UnitTestSwiftCourse.ValidNumber, `print`: UnitTestSwiftCourse.Print) ", arguments: [Mockingbird.ArgumentMatcher(`validNumber`), Mockingbird.ArgumentMatcher(`print`)], returnType: Swift.ObjectIdentifier((Void).self))
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize an initializable class mock of `UnitTestSwiftCourse.Add`.
public func mock(_ type: UnitTestSwiftCourse.Add.Type, file: StaticString = #file, line: UInt = #line) -> AddMock.InitializerProxy.Type {
  return AddMock.InitializerProxy.self
}

// MARK: - Mocked AppDelegate

public final class AppDelegateMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.13.0", "module_name": "UnitTestSwiftCourse"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AppDelegateMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }
}

@available(*, unavailable, message: "'AppDelegate' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: UnitTestSwiftCourse.AppDelegate.Type, file: StaticString = #file, line: UInt = #line) -> AppDelegateMock {
  fatalError()
}

// MARK: - Mocked Calculator

public final class CalculatorMock: UnitTestSwiftCourse.Calculator, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.13.0", "module_name": "UnitTestSwiftCourse"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      CalculatorMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `add`(`n1`: Int, `n2`: Int)

  public override func `add`(`n1`: Int, `n2`: Int) -> Int {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`add`(`n1`: Int, `n2`: Int) -> Int", arguments: [Mockingbird.ArgumentMatcher(`n1`), Mockingbird.ArgumentMatcher(`n2`)], returnType: Swift.ObjectIdentifier((Int).self))
    return mockingContext.didInvoke(invocation) { () -> Int in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Int, Int) -> Int {
        return concreteImplementation(`n1`, `n2`)
      } else if let concreteImplementation = implementation as? () -> Int {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Int).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `add`(`n1`: @escaping @autoclosure () -> Int, `n2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int, Int) -> Int, Int> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`n1`), Mockingbird.resolve(`n2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`add`(`n1`: Int, `n2`: Int) -> Int", arguments: arguments, returnType: Swift.ObjectIdentifier((Int).self))
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int, Int) -> Int, Int>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `divide`(`n1`: Int, `n2`: Int)

  public override func `divide`(`n1`: Int, `n2`: Int) -> Int {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`divide`(`n1`: Int, `n2`: Int) -> Int", arguments: [Mockingbird.ArgumentMatcher(`n1`), Mockingbird.ArgumentMatcher(`n2`)], returnType: Swift.ObjectIdentifier((Int).self))
    return mockingContext.didInvoke(invocation) { () -> Int in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Int, Int) -> Int {
        return concreteImplementation(`n1`, `n2`)
      } else if let concreteImplementation = implementation as? () -> Int {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Int).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `divide`(`n1`: @escaping @autoclosure () -> Int, `n2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int, Int) -> Int, Int> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`n1`), Mockingbird.resolve(`n2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`divide`(`n1`: Int, `n2`: Int) -> Int", arguments: arguments, returnType: Swift.ObjectIdentifier((Int).self))
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int, Int) -> Int, Int>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `divideByZero`(`n1`: Int, `n2`: Int)

  public override func `divideByZero`(`n1`: Int, `n2`: Int) throws -> Int {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`divideByZero`(`n1`: Int, `n2`: Int) throws -> Int", arguments: [Mockingbird.ArgumentMatcher(`n1`), Mockingbird.ArgumentMatcher(`n2`)], returnType: Swift.ObjectIdentifier((Int).self))
    return try mockingContext.didInvoke(invocation) { () -> Int in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Int, Int) throws -> Int {
        return try concreteImplementation(`n1`, `n2`)
      } else if let concreteImplementation = implementation as? () throws -> Int {
        return try concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Int).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `divideByZero`(`n1`: @escaping @autoclosure () -> Int, `n2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int, Int) throws -> Int, Int> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`n1`), Mockingbird.resolve(`n2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`divideByZero`(`n1`: Int, `n2`: Int) throws -> Int", arguments: arguments, returnType: Swift.ObjectIdentifier((Int).self))
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int, Int) throws -> Int, Int>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `subtract`(`n1`: Int, `n2`: Int)

  public override func `subtract`(`n1`: Int, `n2`: Int) -> Int {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`subtract`(`n1`: Int, `n2`: Int) -> Int", arguments: [Mockingbird.ArgumentMatcher(`n1`), Mockingbird.ArgumentMatcher(`n2`)], returnType: Swift.ObjectIdentifier((Int).self))
    return mockingContext.didInvoke(invocation) { () -> Int in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Int, Int) -> Int {
        return concreteImplementation(`n1`, `n2`)
      } else if let concreteImplementation = implementation as? () -> Int {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Int).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `subtract`(`n1`: @escaping @autoclosure () -> Int, `n2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int, Int) -> Int, Int> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`n1`), Mockingbird.resolve(`n2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`subtract`(`n1`: Int, `n2`: Int) -> Int", arguments: arguments, returnType: Swift.ObjectIdentifier((Int).self))
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int, Int) -> Int, Int>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `arraySquared`(`numberArray`: [Int])

  public override func `arraySquared`(`numberArray`: [Int]) -> [Int] {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`arraySquared`(`numberArray`: [Int]) -> [Int]", arguments: [Mockingbird.ArgumentMatcher(`numberArray`)], returnType: Swift.ObjectIdentifier(([Int]).self))
    return mockingContext.didInvoke(invocation) { () -> [Int] in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ([Int]) -> [Int] {
        return concreteImplementation(`numberArray`)
      } else if let concreteImplementation = implementation as? () -> [Int] {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ([Int]).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `arraySquared`(`numberArray`: @escaping @autoclosure () -> [Int]) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, ([Int]) -> [Int], [Int]> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`numberArray`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`arraySquared`(`numberArray`: [Int]) -> [Int]", arguments: arguments, returnType: Swift.ObjectIdentifier(([Int]).self))
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, ([Int]) -> [Int], [Int]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `arraySquared2`(`numberArray`: [Int])

  public override func `arraySquared2`(`numberArray`: [Int]) -> [Int] {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`arraySquared2`(`numberArray`: [Int]) -> [Int]", arguments: [Mockingbird.ArgumentMatcher(`numberArray`)], returnType: Swift.ObjectIdentifier(([Int]).self))
    return mockingContext.didInvoke(invocation) { () -> [Int] in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ([Int]) -> [Int] {
        return concreteImplementation(`numberArray`)
      } else if let concreteImplementation = implementation as? () -> [Int] {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ([Int]).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `arraySquared2`(`numberArray`: @escaping @autoclosure () -> [Int]) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, ([Int]) -> [Int], [Int]> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`numberArray`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`arraySquared2`(`numberArray`: [Int]) -> [Int]", arguments: arguments, returnType: Swift.ObjectIdentifier(([Int]).self))
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, ([Int]) -> [Int], [Int]>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `UnitTestSwiftCourse.Calculator`.
public func mock(_ type: UnitTestSwiftCourse.Calculator.Type, file: StaticString = #file, line: UInt = #line) -> CalculatorMock {
  return CalculatorMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked Print

public final class PrintMock: UnitTestSwiftCourse.Print, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.13.0", "module_name": "UnitTestSwiftCourse"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      PrintMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `showError`()

  public override func `showError`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`showError`() -> Void", arguments: [], returnType: Swift.ObjectIdentifier((Void).self))
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `showError`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`showError`() -> Void", arguments: [], returnType: Swift.ObjectIdentifier((Void).self))
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `showMessage`(`numero`: Int)

  public override func `showMessage`(`numero`: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`showMessage`(`numero`: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`numero`)], returnType: Swift.ObjectIdentifier((Void).self))
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Int) -> Void {
        concreteImplementation(`numero`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `showMessage`(`numero`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`numero`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`showMessage`(`numero`: Int) -> Void", arguments: arguments, returnType: Swift.ObjectIdentifier((Void).self))
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `UnitTestSwiftCourse.Print`.
public func mock(_ type: UnitTestSwiftCourse.Print.Type, file: StaticString = #file, line: UInt = #line) -> PrintMock {
  return PrintMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked SceneDelegate

public final class SceneDelegateMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.13.0", "module_name": "UnitTestSwiftCourse"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      SceneDelegateMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }
}

@available(*, unavailable, message: "'SceneDelegate' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: UnitTestSwiftCourse.SceneDelegate.Type, file: StaticString = #file, line: UInt = #line) -> SceneDelegateMock {
  fatalError()
}

// MARK: - Mocked StringManager

public final class StringManagerMock: UnitTestSwiftCourse.StringManager, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.13.0", "module_name": "UnitTestSwiftCourse"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      StringManagerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `toLowerCased`(`message`: String)

  public override func `toLowerCased`(`message`: String) -> String {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`toLowerCased`(`message`: String) -> String", arguments: [Mockingbird.ArgumentMatcher(`message`)], returnType: Swift.ObjectIdentifier((String).self))
    return mockingContext.didInvoke(invocation) { () -> String in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (String) -> String {
        return concreteImplementation(`message`)
      } else if let concreteImplementation = implementation as? () -> String {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (String).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `toLowerCased`(`message`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String) -> String, String> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`message`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`toLowerCased`(`message`: String) -> String", arguments: arguments, returnType: Swift.ObjectIdentifier((String).self))
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String) -> String, String>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `toUpperCased`(`message`: String)

  public override func `toUpperCased`(`message`: String) -> String {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`toUpperCased`(`message`: String) -> String", arguments: [Mockingbird.ArgumentMatcher(`message`)], returnType: Swift.ObjectIdentifier((String).self))
    return mockingContext.didInvoke(invocation) { () -> String in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (String) -> String {
        return concreteImplementation(`message`)
      } else if let concreteImplementation = implementation as? () -> String {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (String).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `toUpperCased`(`message`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String) -> String, String> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`message`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`toUpperCased`(`message`: String) -> String", arguments: arguments, returnType: Swift.ObjectIdentifier((String).self))
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String) -> String, String>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `UnitTestSwiftCourse.StringManager`.
public func mock(_ type: UnitTestSwiftCourse.StringManager.Type, file: StaticString = #file, line: UInt = #line) -> StringManagerMock {
  return StringManagerMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked TemperatureCalculator

public final class TemperatureCalculatorMock: UnitTestSwiftCourse.TemperatureCalculator, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.13.0", "module_name": "UnitTestSwiftCourse"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TemperatureCalculatorMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `toFahrenheit`(`degree`: Double)

  public override func `toFahrenheit`(`degree`: Double) -> Double {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`toFahrenheit`(`degree`: Double) -> Double", arguments: [Mockingbird.ArgumentMatcher(`degree`)], returnType: Swift.ObjectIdentifier((Double).self))
    return mockingContext.didInvoke(invocation) { () -> Double in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Double) -> Double {
        return concreteImplementation(`degree`)
      } else if let concreteImplementation = implementation as? () -> Double {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Double).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `toFahrenheit`(`degree`: @escaping @autoclosure () -> Double) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Double) -> Double, Double> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`degree`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`toFahrenheit`(`degree`: Double) -> Double", arguments: arguments, returnType: Swift.ObjectIdentifier((Double).self))
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Double) -> Double, Double>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `toDegrees`(`fahrenheit`: Double)

  public override func `toDegrees`(`fahrenheit`: Double) -> Double {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`toDegrees`(`fahrenheit`: Double) -> Double", arguments: [Mockingbird.ArgumentMatcher(`fahrenheit`)], returnType: Swift.ObjectIdentifier((Double).self))
    return mockingContext.didInvoke(invocation) { () -> Double in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Double) -> Double {
        return concreteImplementation(`fahrenheit`)
      } else if let concreteImplementation = implementation as? () -> Double {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Double).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `toDegrees`(`fahrenheit`: @escaping @autoclosure () -> Double) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Double) -> Double, Double> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`fahrenheit`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`toDegrees`(`fahrenheit`: Double) -> Double", arguments: arguments, returnType: Swift.ObjectIdentifier((Double).self))
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Double) -> Double, Double>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `UnitTestSwiftCourse.TemperatureCalculator`.
public func mock(_ type: UnitTestSwiftCourse.TemperatureCalculator.Type, file: StaticString = #file, line: UInt = #line) -> TemperatureCalculatorMock {
  return TemperatureCalculatorMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ValidNumber

public final class ValidNumberMock: UnitTestSwiftCourse.ValidNumber, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.13.0", "module_name": "UnitTestSwiftCourse"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ValidNumberMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `check`(`number`: Int)

  public override func `check`(`number`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`check`(`number`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`number`)], returnType: Swift.ObjectIdentifier((Bool).self))
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Int) -> Bool {
        return concreteImplementation(`number`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `check`(`number`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`number`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`check`(`number`: Int) -> Bool", arguments: arguments, returnType: Swift.ObjectIdentifier((Bool).self))
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `UnitTestSwiftCourse.ValidNumber`.
public func mock(_ type: UnitTestSwiftCourse.ValidNumber.Type, file: StaticString = #file, line: UInt = #line) -> ValidNumberMock {
  return ValidNumberMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ViewController

public final class ViewControllerMock: Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.13.0", "module_name": "UnitTestSwiftCourse"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ViewControllerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }
}

@available(*, unavailable, message: "'ViewController' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: UnitTestSwiftCourse.ViewController.Type, file: StaticString = #file, line: UInt = #line) -> ViewControllerMock {
  fatalError()
}
